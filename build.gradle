plugins {
    id 'java'
    id 'application'
    id 'base'
    id 'nebula.lint' version '9.3.4'
    id 'com.github.hierynomus.license' version '0.15.0'
}

apply plugin: 'java'
apply plugin: 'base'
apply plugin: 'nebula.lint'
apply plugin: 'com.github.hierynomus.license'
apply plugin: "application"

repositories {
   mavenLocal()
   jcenter()
}

dependencies {
  implementation 'org.slf4j:slf4j-api:1.7.26'
  implementation 'com.fasterxml.jackson.core:jackson-databind:2.9.8' 
  implementation 'org.jasypt:jasypt:1.9.2'
  runtimeOnly 'org.slf4j:slf4j-simple:1.6.4'
  testImplementation "junit:junit:$junitVersion"
}

group = 'org.apereo.openequella.adminconsole'
version = artifactVersion
mainClassName = 'org.apereo.openequella.adminconsole.launcher.ClientLauncher'

// Gradlelint is broken: https://github.com/nebula-plugins/gradle-lint-plugin/issues/203
gradleLint.rules = [/*'all-dependency', */'dependency-parentheses', 'duplicate-dependency-class']

license {
    strictCheck
    header = file('LICENSE')
}


jar {
  archiveFileName = 'admin.jar'
  manifest {
      attributes('Implementation-Title': project.name,
              'Implementation-Version': project.version,
              'Main-Class': mainClassName)
  }
}

task cleanDist() {
  dependsOn 'clean'
  doLast {
    delete 'dist'
  }
}

task copyDistArtifacts(type: Copy) {
  dependsOn 'copyScripts'

  from(file('build/libs/admin.jar'))
  from configurations.default
  into('dist/lib')
}

task copyScripts(type: Copy){
  dependsOn 'cleanDist', 'jar'

  from(file('scripts'))
  into('dist')
  include('**/*')
}

task dist {
  description 'Copies everything required for the distributable into a dist folder'
  dependsOn 'copyDistArtifacts'
}

ext {
    osNames = ['linux', 'windows', 'mac']
    jreFileNameTemplate = {sys,extension -> "OpenJDK8U-jre_x64_${sys}_hotspot_8u212b03.${extension}" }
    jreDownloadDir = file("$buildDir/jre-downloads")
    jreExtractDir = "${jreDownloadDir.absolutePath}/jre"
    jreExtractSubDir = {sys -> "${jreExtractDir}/$sys"}
    jreHashes = ['74daf0b77a7fd679cbb3a6228e0efa8c4a90b7664aa057f211e34bbfb38640fb',
                 'c09bab89cd82483c371597c5c364094a145c1fbba43a1d3d7c3e350b89dedc89',
                 '80855320c42a3b06617c6e466c64df67731542a805972185b075ca6cb1222c7f']
    packageFileExtension = ['zip', 'tar.gz']
}

import java.security.MessageDigest

task downloadJre(description: 'Download OpenJRE of Linux, Windows and Mac, and check their hashes') {

    doFirst {
        if(!jreDownloadDir.exists()) {
            jreDownloadDir.mkdirs()
        }
        osNames.each {String sys ->
            def index = osNames.indexOf(sys)
            def jreFileExtension = (sys == 'windows' ? packageFileExtension[0] : packageFileExtension[1])
            def jreFileName = jreFileNameTemplate(sys,jreFileExtension)
            def jreFile = file("$jreDownloadDir.absolutePath/$jreFileName")
            if(!jreFile.exists()){
                new URL("https://github.com/AdoptOpenJDK/openjdk8-binaries/releases/download/jdk8u212-b03/$jreFileName")
                        .withInputStream {
                    jreFile.newOutputStream() << it
                }
                final hash = MessageDigest.getInstance('SHA-256').with {
                    jreFile.eachByte(1024) {buff,len ->
                        update(buff, 0, len)
                    }
                    digest().encodeHex() as String
                }
                if(hash != jreHashes[index]) {
                    throw new RuntimeException("Hash mismatch for downloaded $sys JRE. File may have been modified.")
                }
            }
        }
        
    }
}

task unzipJre(description: 'Unzip JREs only when the extract directory is not existing', dependsOn:downloadJre) {
    doFirst {
        fileTree(jreDownloadDir).matching {
            exclude 'jre'
        }.each { jreFile ->
                 if(jreFile.name.endsWith('zip')) {
                     copy {
                         from zipTree(jreFile)
                         into jreExtractSubDir('windows')
                     }
                 }
                 else {
                     copy {
                         from tarTree(resources.gzip(jreFile))
                         into jreExtractSubDir(jreFile.name.contains('mac') ? 'mac' : 'linux')
                     }
                 }
        }
    }
}

unzipJre.onlyIf {
    !file(jreExtractDir).exists()
}

task createPackages(description: 'Create three packages for Linux, Windows and Mac', dependsOn:unzipJre) {
    //This task also depends on other three tasks which are created by iterating osNames
}

osNames.each {String sys ->
    def packageDir = new File("$buildDir/distributions/packages")
    def (taskType, fileExtension, fileCompression, scriptFile) = setPackageProperties(sys)
    def taskCLass = Class.forName(taskType)
    def jarDir = file("$buildDir/libs")
    def scriptDir = file("$projectDir/launcher-scripts")
    task "packageFor$sys"(type: taskCLass){
        mustRunAfter unzipJre
        archiveBaseName = "admin-console-package-for-$sys"
        extension = fileExtension
        if(fileCompression) compression = Compression.GZIP
        destinationDirectory = packageDir
        from jarDir
        from file(jreExtractSubDir(sys))
        exclude (['*.zip', '*.tar.gz'])
        from file("${scriptDir.getAbsolutePath()}/$scriptFile")

        doLast {
            println("Package for $sys is created under ${packageDir.absolutePath}")
        }
    }
    createPackages.dependsOn("packageFor$sys")
}

def setPackageProperties(String sys) {
    def scriptFile
    def taskType
    def fileExtension
    def fileCompression
    def gradleBundlingTaskPackage = { type -> "org.gradle.api.tasks.bundling.$type" }
    def scriptFileNames = ['Windows-launcher.bat', 'Linux-launcher.sh', 'Mac-launcher.dmg']

    if(sys == osNames[1]){
        taskType = gradleBundlingTaskPackage('Zip')
        fileExtension = packageFileExtension[0]
        fileCompression = false
        scriptFile = scriptFileNames[0]
    }
    else if (sys == osNames[0]){
        taskType = gradleBundlingTaskPackage('Tar')
        fileExtension = packageFileExtension[1]
        fileCompression = true
        scriptFile = scriptFileNames[1]
    }
    else {
        taskType = gradleBundlingTaskPackage('Tar')
        fileExtension = packageFileExtension[1]
        fileCompression = true
        scriptFile = scriptFileNames[2]
    }
    return new Tuple4(taskType,fileExtension,fileCompression,scriptFile)
}

build.finalizedBy(createPackages)
